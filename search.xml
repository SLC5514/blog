<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jQuery基础收录</title>
    <url>/blog/2019/12/06/jQuery%E5%9F%BA%E7%A1%80%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<p>jQuery 相关知识收录（基础）</p>
<a id="more"></a>

<h2 id="jQuery-设计思想"><a href="#jQuery-设计思想" class="headerlink" title="jQuery 设计思想"></a>jQuery 设计思想</h2><blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html" target="_blank" rel="noopener">jQuery 设计思想</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>收录</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript基础收录</title>
    <url>/blog/2019/12/06/Javascript%E5%9F%BA%E7%A1%80%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<p>JavaScript 相关知识收录（基础）</p>
<a id="more"></a>

<h2 id="Javascript-诞生记"><a href="#Javascript-诞生记" class="headerlink" title="Javascript 诞生记"></a>Javascript 诞生记</h2><blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html" target="_blank" rel="noopener">Javascript 诞生记</a></cite></footer></blockquote>

<h2 id="Javascript-的-10-个设计缺陷"><a href="#Javascript-的-10-个设计缺陷" class="headerlink" title="Javascript 的 10 个设计缺陷"></a>Javascript 的 10 个设计缺陷</h2><blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html" target="_blank" rel="noopener">Javascript 的 10 个设计缺陷</a></cite></footer></blockquote>

<h2 id="var-命令的“代码提升”（hoisting）"><a href="#var-命令的“代码提升”（hoisting）" class="headerlink" title="var 命令的“代码提升”（hoisting）"></a>var 命令的“代码提升”（hoisting）</h2><blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_judge_the_existence_of_a_global_object_in_javascript.html" target="_blank" rel="noopener">如何判断 Javascript 对象是否存在</a></cite></footer></blockquote>

<h2 id="继承机制（new-constructor-prototype）"><a href="#继承机制（new-constructor-prototype）" class="headerlink" title="继承机制（new constructor prototype）"></a>继承机制（new constructor prototype）</h2><blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript 继承机制的设计思想</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>收录</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>收录</tag>
      </tags>
  </entry>
  <entry>
    <title>JS十大排序算法</title>
    <url>/blog/2019/12/06/JS%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>排序算法（<strong>Sorting algorithm</strong>）是计算机科学最古老、最基本的课题之一。要想成为合格的程序员，就必须理解和掌握各种排序算法。</p>
<p>目前，最常见的排序算法大概有七八种，其中”快速排序”（<strong>Quicksort</strong>）使用得最广泛，速度也较快。</p>
<a id="more"></a>

<img class="[class names]" data-src="/blog/images/sort/js-sort.webp">

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。</p>
<p>最好：<code>O(n)</code>，只需要冒泡一次数组就有序了。<br>最坏：<code>O(n²)</code><br>平均：<code>O(n²)</code></p>
<h3 id="单向冒泡"><a href="#单向冒泡" class="headerlink" title="单向冒泡"></a>单向冒泡</h3><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len - <span class="number">1</span>; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果一轮比较中没有需要交换的数据，则说明数组已经有序。主要是对[5,1,2,3,4]之类的数组进行优化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> mark = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [nums[j], nums[j + <span class="number">1</span>]] = [nums[j + <span class="number">1</span>], nums[j]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mark = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (mark) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h3 id="双向冒泡"><a href="#双向冒泡" class="headerlink" title="双向冒泡"></a>双向冒泡</h3><p>普通的冒泡排序在一趟循环中只能找出一个最大值或最小值，双向冒泡则是多一轮循环既找出最大值也找出最小值。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort_twoWays</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> high = nums.length - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (low &lt; high) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> mark = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 找到最大值放到右边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = low; i &lt; high; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [nums[i], nums[i + <span class="number">1</span>]] = [nums[i + <span class="number">1</span>], nums[i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mark = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    high--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 找到最小值放到左边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = high; j &gt; low; j--) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [nums[j], nums[j - <span class="number">1</span>]] = [nums[j - <span class="number">1</span>], nums[j]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mark = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    low++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (mark) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><img class="[class names]" data-src="/blog/images/sort/select-sort.gif">

<p>和冒泡排序相似，区别在于选择排序是将每一个元素和它后面的元素进行比较和交换。</p>
<p>最好：<code>O(n²)</code><br>最坏：<code>O(n²)</code><br>平均：<code>O(n²)</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[j]) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [nums[i], nums[j]] = [nums[j], nums[i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img class="[class names]" data-src="/blog/images/sort/insert-sort.gif">

<p>以第一个元素作为有序数组，其后的元素通过在这个已有序的数组中找到合适的位置并插入。</p>
<p>最好：<code>O(n)</code>，原数组已经是升序的。<br>最坏：<code>O(n²)</code><br>平均：<code>O(n²)</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = nums.length; i &lt; len; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> temp = nums[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> j = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; nums[j - <span class="number">1</span>]) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      nums[j] = nums[j - <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      j--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nums[j] = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><img class="[class names]" data-src="/blog/images/sort/quick-sort.gif">

<p>选择一个元素作为基数（通常是第一个元素），把比基数小的元素放到它左边，比基数大的元素放到它右边（相当于二分），再不断递归基数左右两边的序列。</p>
<p>最好：<code>O(n * logn)</code>，所有数均匀分布在基数的两边，此时的递归就是不断地二分左右序列。<br>最坏：<code>O(n²)</code>，所有数都分布在基数的一边，此时划分左右序列就相当于是插入排序。<br>平均：<code>O(n * logn)</code></p>
<p>参考学习链接：<br><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html" target="_blank" rel="noopener">算法 3：最常用的排序——快速排序</a></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> arr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> left = [];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> right = [];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      left.push(arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      right.push(arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// return [...quickSort(left), numValue, ...quickSort(right)];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr></tbody></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><img class="[class names]" data-src="/blog/images/sort/merge-sort.gif">

<p>递归将数组分为两个序列，有序合并这两个序列。</p>
<p>最好：<code>O(n _ logn)</code><br>最坏：<code>O(n _ logn)</code><br>平均：<code>O(n * logn)</code></p>
<p>参考学习链接：<br><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 有序合并两个数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">l1, r1, l2, r2</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> arr = [];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> i = l1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      j = l2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (i &lt;= r1 &amp;&amp; j &lt;= r2) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      arr[index++] = nums[i] &lt; nums[j] ? nums[i++] : nums[j++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (i &lt;= r1) arr[index++] = nums[i++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (j &lt;= r2) arr[index++] = nums[j++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将有序合并后的数组修改回原数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> t = <span class="number">0</span>; t &lt; index; t++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      nums[l1 + t] = arr[t];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 递归将数组分为两个序列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">left, right</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 比起(left+right)/2，更推荐下面这种写法，可以避免数溢出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((right - left) / <span class="number">2</span>) + left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    recursive(left, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    recursive(mid + <span class="number">1</span>, right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    merge(left, mid, mid + <span class="number">1</span>, right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> nums;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  recursive(<span class="number">0</span>, nums.length - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>取 n 个桶，根据数组的最大值和最小值确认每个桶存放的数的区间，将数组元素插入到相应的桶里，最后再合并各个桶。</p>
<p>最好：<code>O(n)</code>，每个数都在分布在一个桶里，这样就不用将数插入排序到桶里了(类似于计数排序以空间换时间)。<br>最坏：<code>O(n²)</code>，所有的数都分布在一个桶里。<br>平均：<code>O(n + k)</code>，k 表示桶的个数。</p>
<p>参考学习链接：<br><a href="https://zhuanlan.51cto.com/art/201811/586129.htm" target="_blank" rel="noopener">拜托，面试别再问我桶排序了！！！</a></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 桶的个数，只要是正数即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> num = <span class="number">5</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 计算每个桶存放的数值范围，至少为1，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> range = <span class="built_in">Math</span>.ceil((max - min) / num) || <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 创建二维数组，第一维表示第几个桶，第二维表示该桶里存放的数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(num)).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Array</span>().fill(<span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  nums.forEach(<span class="function"><span class="params">val</span> =&gt;</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 计算元素应该分布在哪个桶</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> index = <span class="built_in">parseInt</span>((val - min) / range);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 防止index越界，例如当[5,1,1,2,0,0]时index会出现5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    index = index &gt;= num ? num - <span class="number">1</span> : index;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> temp = arr[index];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 插入排序，将元素有序插入到桶中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> j = temp.length - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; val &lt; temp[j]) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      temp[j + <span class="number">1</span>] = temp[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      j--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp[j + <span class="number">1</span>] = val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  });</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 修改回原数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> res = [].concat.apply([], arr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  nums.forEach(<span class="function">(<span class="params">val, i</span>) =&gt;</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nums[i] = res[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  });</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>使用十个桶 0-9，把每个数从低位到高位根据位数放到相应的桶里，以此循环最大值的位数次。<br><strong>但只能排列正整数，因为遇到负号和小数点无法进行比较</strong>。</p>
<p>最好：<code>O(n * k)</code>，k 表示最大值的位数。<br>最坏：<code>O(n * k)</code><br>平均：<code>O(n * k)</code></p>
<p>参考学习链接：<br><a href="https://www.cnblogs.com/sun/archive/2008/06/26/1230095.html" target="_blank" rel="noopener">算法总结系列之五: 基数排序(Radix Sort)</a></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 计算位数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getDigits</span>(<span class="params">n</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (n) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      sum++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      n = <span class="built_in">parseInt</span>(n / <span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 第一维表示位数即0-9，第二维表示里面存放的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">10</span>)).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Array</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> maxDigits = getDigits(max);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 用0把每一个数都填充成相同的位数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    nums[i] = (nums[i] + <span class="string">""</span>).padStart(maxDigits, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 先根据个位数把每一个数放到相应的桶里</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> temp = nums[i][nums[i].length - <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arr[temp].push(nums[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 循环判断每个位数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = maxDigits - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 循环每一个桶</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">let</span> temp = arr[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">let</span> len = temp.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// 根据当前的位数i把桶里的数放到相应的桶里</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">while</span> (len--) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> str = temp[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp.shift();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[str[i]].push(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 修改回原数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> res = [].concat.apply([], arr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  nums.forEach(<span class="function">(<span class="params">val, index</span>) =&gt;</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nums[index] = +res[index];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  });</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>以数组元素值为键，出现次数为值存进一个临时数组，最后再遍历这个临时数组还原回原数组。<br>因为 JavaScript 的数组下标是以字符串形式存储的，所以<strong>计数排序可以用来排列负数，但不可以排列小数</strong>。</p>
<p>最好：<code>O(n + k)</code>，k 是最大值和最小值的差。<br>最坏：<code>O(n + k)</code><br>平均：<code>O(n + k)</code></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> arr = [];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 装桶</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> temp = nums[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arr[temp] = arr[temp] + <span class="number">1</span> || <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 还原原数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = min; i &lt;= max; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (arr[i] &gt; <span class="number">0</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      nums[index++] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      arr[i]--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="计数排序优化"><a href="#计数排序优化" class="headerlink" title="计数排序优化"></a>计数排序优化</h2><p>把每一个数组元素都加上 <code>min</code> 的相反数，来避免特殊情况下的空间浪费，通过这种优化可以把所开的空间大小从 <code>max+1</code> 降低为 <code>max-min+1</code>，<code>max</code> 和 <code>min</code> 分别为数组中的最大值和最小值。</p>
<p>比如数组 <code>[103, 102, 101, 100]</code>，普通的计数排序需要开一个长度为 104 的数组，而且前面 100 个值都是 <code>undefined</code>，使用该优化方法后可以只开一个长度为 4 的数组。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> arr = [];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 加上最小值的相反数来缩小数组范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> add = -min;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> temp = nums[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp += add;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arr[temp] = arr[temp] + <span class="number">1</span> || <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = min; i &lt;= max; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> temp = arr[i + add];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      nums[index++] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      temp--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>根据数组建立一个堆（类似完全二叉树），每个结点的值都大于左右结点（最大堆，通常用于升序），或小于左右结点（最小堆，通常用于降序）。对于升序排序，先构建最大堆后，交换堆顶元素（表示最大值）和堆底元素，每一次交换都能得到未有序序列的最大值。重新调整最大堆，再交换堆顶元素和堆底元素，重复 n-1 次后就能得到一个升序的数组。</p>
<p>最好：<code>O(n * logn)</code>，logn 是调整最大堆所花的时间。<br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code></p>
<p>参考学习链接：<br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法 - 堆排序 (Heap Sort)</a><br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 调整最大堆，使index的值大于左右节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">adjustHeap</span>(<span class="params">nums, index, size</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 交换后可能会破坏堆结构，需要循环使得每一个父节点都大于左右结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">let</span> max = index;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">let</span> left = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">let</span> right = index * <span class="number">2</span> + <span class="number">2</span>; <span class="comment">// 右节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (left &lt; size &amp;&amp; nums[max] &lt; nums[left]) max = left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (right &lt; size &amp;&amp; nums[max] &lt; nums[right]) max = right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// 如果左右结点大于当前的结点则交换，并再循环一遍判断交换后的左右结点位置是否破坏了堆结构（比左右结点小了）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (index !== max) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [nums[index], nums[max]] = [nums[max], nums[index]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        index = max;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 建立最大堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildHeap</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 注意这里的头节点是从0开始的，所以最后一个非叶子结点是 parseInt(nums.length/2)-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> start = <span class="built_in">parseInt</span>(nums.length / <span class="number">2</span>) - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> size = nums.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 从最后一个非叶子结点开始调整，直至堆顶。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      adjustHeap(nums, i, size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  buildHeap(nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 循环n-1次，每次循环后交换堆顶元素和堆底元素并重新调整堆结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [nums[i], nums[<span class="number">0</span>]] = [nums[<span class="number">0</span>], nums[i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    adjustHeap(nums, <span class="number">0</span>, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。</p>
<p>最好：<code>O(n * logn)</code>，步长不断二分。<br>最坏：<code>O(n * logn)</code><br>平均：<code>O(n * logn)</code></p>
<p>参考学习链接：<br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" target="_blank" rel="noopener">图解排序算法(二)之希尔排序</a></p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">nums</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> len = nums.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 初始步数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> gap = <span class="built_in">parseInt</span>(len / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 逐渐缩小步数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (gap) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 从第gap个元素开始遍历</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// 逐步其和前面其他的组成员进行比较和交换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (nums[j] &gt; nums[j + gap]) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">          [nums[j], nums[j + gap]] = [nums[j + gap], nums[j]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        }</span></pre></td></tr><tr><td class="code"><pre><span class="line">      }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gap = <span class="built_in">parseInt</span>(gap / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<blockquote><footer><strong>___n</strong><cite><a href="https://www.jianshu.com/p/a6ef6e0d1227" target="_blank" rel="noopener">JS十大排序算法</a></cite></footer></blockquote>

<blockquote><footer><strong>码农1213</strong><cite><a href="https://www.cnblogs.com/bear-blogs/p/10808399.html" target="_blank" rel="noopener">js 常用排序</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程（三）：非构造函数的继承</title>
    <url>/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%9D%9E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>这个系列的 <a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/" title="第一部分">第一部分</a> 介绍了“封装”，<a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/" title="第二部分">第二部分</a> 介绍了使用构造函数实现“继承”。</p>
<p>今天是最后一个部分，介绍不使用构造函数实现“继承”。</p>
<a id="more"></a>

<h2 id="什么是“非构造函数”的继承？"><a href="#什么是“非构造函数”的继承？" class="headerlink" title="什么是“非构造函数”的继承？"></a>什么是“非构造函数”的继承？</h2><p>比如，现在有一个对象，叫做”中国人”。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Chinese = {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  nation: <span class="string">"中国"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr></tbody></table></figure>

<p>还有一个对象，叫做”医生”。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Doctor = {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  career: <span class="string">"医生"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr></tbody></table></figure>

<p>请问怎样才能让“医生”去继承“中国人”，也就是说，我怎样才能生成一个“中国医生”的对象？</p>
<p>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现“继承”。</p>
<h2 id="object-方法"><a href="#object-方法" class="headerlink" title="object()方法"></a>object()方法</h2><p><strong>json</strong> 格式的发明人 <strong>Douglas Crockford</strong>，提出了一个 <strong>object()</strong> 函数，可以做到这一点。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>{}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  F.prototype = o;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Doctor = object(Chinese); <span class="comment">// 第一步先在父对象的基础上，生成子对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Doctor.career = <span class="string">"医生"</span>; <span class="comment">// 再加上子对象本身的属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Doctor.nation); <span class="comment">//中国</span></span></pre></td></tr></tbody></table></figure>

<p>这个 <strong>object()</strong> 函数其实只做一件事，就是把子对象的 <code>prototype</code> 属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>除了使用“prototype 链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    c[i] = p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.uber = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Doctor = extendCopy(Chinese);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Doctor.career = <span class="string">"医生"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Doctor.nation); <span class="comment">// 中国</span></span></pre></td></tr></tbody></table></figure>

<p>这样的拷贝有一个问题。如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>所以，<strong>extendCopy()</strong> 只是拷贝基本类型的数据，我们把这种拷贝叫做“浅拷贝”。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>所谓“深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用“浅拷贝”就行了。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c = c || {};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">"object"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      c[i] = p[i].constructor === <span class="built_in">Array</span> ? [] : {};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      deepCopy(p[i], c[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      c[i] = p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Doctor = deepCopy(Chinese);</span></pre></td></tr></tbody></table></figure>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="noopener">Javascript 面向对象编程（三）：非构造函数的继承</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程（二）：构造函数的继承</title>
    <url>/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>这个系列的 <a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/" title="第一部分">第一部分</a>，主要介绍了如何“封装”数据和方法，以及如何从原型对象生成实例。</p>
<p>今天要介绍的是，对象之间“继承”的五种方法。</p>
<a id="more"></a>

<p>比如，现在有一个“动物”对象的构造函数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>还有一个“猫”对象的构造函数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>怎样才能使“猫”继承“动物”呢？</p>
<h2 id="构造函数绑定"><a href="#构造函数绑定" class="headerlink" title="构造函数绑定"></a>构造函数绑定</h2><p>第一种方法也是最简单的方法，使用 <code>call</code> 或 <code>apply</code> 方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr></tbody></table></figure>

<h2 id="prototype-模式"><a href="#prototype-模式" class="headerlink" title="prototype 模式"></a>prototype 模式</h2><p>第二种方法更常见，使用 <code>prototype</code> 属性。</p>
<p>如果”猫”的 <code>prototype</code> 对象，指向一个 <strong>Animal</strong> 的实例，那么所有“猫”的实例，就能继承 <strong>Animal</strong> 了。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal(); <span class="comment">// 它相当于完全删除了 prototype 对象原先的值，然后赋予一个新值。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat.prototype.constructor = Cat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr></tbody></table></figure>

<p>任何一个 <code>prototype</code> 对象都有一个 <code>constructor</code> 属性，指向它的构造函数。<br>如果没有“<strong>Cat.prototype = new Animal();</strong>”这一行，<strong>Cat.prototype.constructor</strong> 是指向 <strong>Cat</strong> 的；<br>加了这一行以后，<strong>Cat.prototype.constructor</strong> 指向 <strong>Animal</strong>。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(Cat.prototype.constructor == Animal); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p>更重要的是，每一个实例也有一个 <code>constructor</code> 属性，默认调用 <code>prototype</code> 对象的 <code>constructor</code> 属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.constructor == Cat.prototype.constructor); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p>因此，在运行“<strong>Cat.prototype = new Animal();</strong>”这一行之后，<strong>cat1.constructor</strong> 也指向 <strong>Animal</strong>！</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.constructor == Animal); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p>这显然会导致继承链的紊乱（<strong>cat1</strong> 明明是用构造函数 <strong>Cat</strong> 生成的），因此我们必须手动纠正，将 <strong>Cat.prototype</strong> 对象的 <strong>constructor</strong> 值改为 <strong>Cat</strong>。这就是第二行的意思。</p>
<p>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了 <code>prototype</code> 对象，那么，下一步必然是为新的 <code>prototype</code> 对象加上 <code>constructor</code> 属性，并将这个属性指回原来的构造函数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">o.prototype = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">o.prototype.constructor = o;</span></pre></td></tr></tbody></table></figure>

<h2 id="直接继承-prototype"><a href="#直接继承-prototype" class="headerlink" title="直接继承 prototype"></a>直接继承 prototype</h2><p>第三种方法是对第二种方法的改进。由于 <strong>Animal</strong> 对象中，不变的属性都可以直接写入 <strong>Animal.prototype</strong>。所以，我们也可以让 <strong>Cat()</strong> 跳过 <strong>Animal()</strong>，直接继承 <code>Animal.prototype</code>。</p>
<p>现在，我们先将 Animal 对象改写：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>{}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Animal.prototype.species = <span class="string">"动物"</span>;</span></pre></td></tr></tbody></table></figure>

<p>然后，将 <strong>Cat</strong> 的 <code>prototype</code> 对象指向 <strong>Animal</strong> 的 <code>prototype</code> 对象，这样就完成了继承。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">Cat.prototype = Animal.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat.prototype.constructor = Cat; <span class="comment">// 这一句实际上把 Animal.prototype 对象的 constructor 属性也改掉了！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 缺点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Animal.prototype.constructor); <span class="comment">// Cat</span></span></pre></td></tr></tbody></table></figure>

<p>这样做的优点是效率比较高（不用执行和建立 <strong>Animal</strong> 的实例了），比较省内存。</p>
<p>缺点是 <strong>Cat.prototype</strong> 和 <strong>Animal.prototype</strong> 现在指向了同一个对象，那么任何对 <strong>Cat.prototype</strong> 的修改，都会反映到 <strong>Animal.prototype</strong>。所以，上面这一段代码其实是有问题的。请看第二行。</p>
<h2 id="利用空对象作为中介"><a href="#利用空对象作为中介" class="headerlink" title="利用空对象作为中介"></a>利用空对象作为中介</h2><p>由于“直接继承 prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  F.prototype = Parent.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Child.prototype = <span class="keyword">new</span> F();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Child.prototype.constructor = Child;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Child.uber = Parent.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 意思是为子对象设一个 uber 属性，这个属性直接指向父对象的 prototype 属性。（ uber 是一个德语词，意思是“向上”、“上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">extend(Cat, Animal);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Animal.prototype.constructor); <span class="comment">// Animal</span></span></pre></td></tr></tbody></table></figure>

<p><strong>F</strong> 是空对象，所以几乎不占内存。这时，修改 <strong>Cat</strong> 的 <code>prototype</code> 对象，就不会影响到 <strong>Animal</strong> 的 <code>prototype</code> 对象。</p>
<h2 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h2><p>上面是采用 <code>prototype</code> 对象实现继承。我们也可以换一种思路，纯粹采用“拷贝”方法实现继承。<br>简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把 Animal 的所有不变属性，都放到它的 prototype 对象上。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>{}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Animal.prototype.species = <span class="string">"动物"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 然后，再写一个函数，实现属性拷贝的目的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> p = Parent.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c = Child.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    c[i] = p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.uber = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">extend2(Cat, Animal);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr></tbody></table></figure>

<p>这个函数的作用，就是将父对象的 <code>prototype</code> 对象中的属性，一一拷贝给 <strong>Child</strong> 对象的 <code>prototype</code> 对象。</p>
<p>未完，请继续阅读这个系列的第三部分 <a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%9D%9E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF/" title="《非构造函数的继承》">《非构造函数的继承》</a>。</p>
<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript 面向对象编程（二）：构造函数的继承</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程（一）：封装</title>
    <url>/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p><strong>Javascript</strong> 是一种基于对象（<strong>object-based</strong>）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（<strong>OOP</strong>）语言，因为它的语法中没有 <code>class</code>（类）。</p>
<p>那么，如果我们要把”属性”（<strong>property</strong>）和”方法”（<strong>method</strong>），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？</p>
<a id="more"></a>

<h2 id="生成实例对象的原始模式"><a href="#生成实例对象的原始模式" class="headerlink" title="生成实例对象的原始模式"></a>生成实例对象的原始模式</h2><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: <span class="string">""</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  color: <span class="string">""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = {}; <span class="comment">// 创建一个空对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat1.name = <span class="string">"大毛"</span>; <span class="comment">// 按照原型对象的属性赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat1.color = <span class="string">"黄色"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat2.name = <span class="string">"二毛"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat2.color = <span class="string">"黑色"</span>;</span></pre></td></tr></tbody></table></figure>

<p>这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>
<h2 id="原始模式的改进"><a href="#原始模式的改进" class="headerlink" title="原始模式的改进"></a>原始模式的改进</h2><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: name,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: color</span></pre></td></tr><tr><td class="code"><pre><span class="line">  };</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = Cat(<span class="string">"二毛"</span>, <span class="string">"黑色"</span>);</span></pre></td></tr></tbody></table></figure>

<p>这种方法的问题依然是，<strong>cat1</strong> 和 <strong>cat2</strong> 之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>为了解决从原型对象生成实例的问题，<strong>Javascript</strong> 提供了一个构造函数（<strong>Constructor</strong>）模式。</p>
<p>所谓“构造函数”，其实就是一个普通函数，但是内部使用了 <code>this</code> 变量。对构造函数使用 <code>new</code> 运算符，就能生成实例，并且 <code>this</code> 变量会绑定在实例对象上。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>, <span class="string">"黑色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.name); <span class="comment">// 大毛</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.color); <span class="comment">// 黄色</span></span></pre></td></tr></tbody></table></figure>

<p>这时 <strong>cat1</strong> 和 <strong>cat2</strong> 会自动含有一个 <code>constructor</code> 属性，指向它们的构造函数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.constructor == Cat); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat2.constructor == Cat); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p><strong>Javascript</strong> 还提供了一个 <code>instanceof</code> 运算符，验证原型对象与实例对象之间的关系。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1 <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat2 <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<h2 id="构造函数模式的问题"><a href="#构造函数模式的问题" class="headerlink" title="构造函数模式的问题"></a>构造函数模式的问题</h2><p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>
<p>我们现在为 <strong>Cat</strong> 对象添加一个不变的属性 <strong>type</strong>（种类），再添加一个方法 <strong>eat</strong>（吃）。那么，原型对象 <strong>Cat</strong> 就变成了下面这样：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.type = <span class="string">"猫科动物"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(<span class="string">"吃老鼠"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  };</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>, <span class="string">"黑色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.type); <span class="comment">// 猫科动物</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat1.eat(); <span class="comment">// 吃老鼠</span></span></pre></td></tr></tbody></table></figure>

<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。<br>那就是对于每一个实例对象，<strong>type</strong> 属性和 <strong>eat()</strong> 方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.eat == cat2.eat); <span class="comment">// false</span></span></pre></td></tr></tbody></table></figure>

<h2 id="Prototype-模式"><a href="#Prototype-模式" class="headerlink" title="Prototype 模式"></a>Prototype 模式</h2><p><strong>Javascript</strong> 规定，每一个构造函数都有一个 <code>prototype</code> 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在 <code>prototype</code> 对象上。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat.prototype.type = <span class="string">"猫科动物"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  alert(<span class="string">"吃老鼠"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>, <span class="string">"黑色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.type); <span class="comment">// 猫科动物</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat1.eat(); <span class="comment">// 吃老鼠</span></span></pre></td></tr></tbody></table></figure>

<p>这时所有实例的 <strong>type</strong> 属性和 <strong>eat()</strong> 方法，其实都是同一个内存地址，指向 <code>prototype</code> 对象，因此就提高了运行效率。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.eat == cat2.eat); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<h2 id="Prototype-模式的验证方法"><a href="#Prototype-模式的验证方法" class="headerlink" title="Prototype 模式的验证方法"></a>Prototype 模式的验证方法</h2><p>为了配合 <code>prototype</code> 属性，<strong>Javascript</strong> 定义了一些辅助方法，帮助我们使用它。</p>
<h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h3><p>这个方法用来判断，某个 <code>proptotype</code> 对象和某个实例之间的关系。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(Cat.prototype.isPrototypeOf(cat1)); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Cat.prototype.isPrototypeOf(cat2)); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3><p>每个实例对象都有一个 <code>hasOwnProperty()</code> 方法，用来判断某一个属性到底是本地属性，还是继承自 <code>prototype</code> 对象的属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.hasOwnProperty(<span class="string">"type"</span>)); <span class="comment">// false</span></span></pre></td></tr></tbody></table></figure>

<h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p><code>in</code> 运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> cat1); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(<span class="string">"type"</span> <span class="keyword">in</span> cat1); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p><code>in</code> 运算符还可以用来遍历某个对象的所有属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> cat1) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  alert(<span class="string">"cat1["</span> + prop + <span class="string">"]="</span> + cat1[prop]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>未完，请继续阅读这个系列的第二部分 <a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF/" title="《构造函数的继承》">《构造函数的继承》</a> 和第三部分 《非构造函数的继承》。</p>
<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="noopener">Javascript 面向对象编程（一）：封装</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 的 this 用法</title>
    <url>/blog/2019/12/05/Javascript%E7%9A%84this%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><code>this</code> 是 <strong>JavaScript</strong> 语言的一个关键字。</p>
<p>它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。</p>
<p>函数的不同使用场合，<code>this</code> 有不同的值。总的来说，<code>this</code> 就是函数运行时所在的环境对象。</p>
<a id="more"></a>

<h2 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：纯粹的函数调用</h2><p>这是函数的最通常用法，属于全局性调用，因此 <code>this</code> 就代表全局对象。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h2><p>函数还可以作为某个对象的方法调用，这时 <code>this</code> 就指这个上级对象。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.m = test;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.m(); <span class="comment">// 1</span></span></pre></td></tr></tbody></table></figure>

<h2 id="情况三-作为构造函数调用"><a href="#情况三-作为构造函数调用" class="headerlink" title="情况三 作为构造函数调用"></a>情况三 作为构造函数调用</h2><p>所谓构造函数，就是通过这个函数，可以生成一个新对象。这时，<code>this</code> 就指这个新对象。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.x; <span class="comment">// 1</span></span></pre></td></tr></tbody></table></figure>

<h2 id="情况四-apply-调用"><a href="#情况四-apply-调用" class="headerlink" title="情况四 apply 调用"></a>情况四 apply 调用</h2><p><code>apply()</code> 是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时 <code>this</code> 指的就是这第一个参数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.m = test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.m.apply(); <span class="comment">// 0</span></span></pre></td></tr></tbody></table></figure>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">Javascript 的 this 用法</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>12种不宜使用的Javascript语法</title>
    <url>/blog/2019/12/05/12%E7%A7%8D%E4%B8%8D%E5%AE%9C%E4%BD%BF%E7%94%A8%E7%9A%84Javascript%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>在《Javascript 语言精粹》附录 B 中，<strong>Douglas Crockford</strong> 列出了 12 种应该避免使用的 <strong>Javascript</strong> 语法，我觉得非常值得推广。</p>
<a id="more"></a>

<h2 id><a href="#" class="headerlink" title="=="></a>==</h2><p><strong>Javascript</strong> 有两组相等运算符，一组是 <code>==</code> 和 <code>!=</code>，另一组是 <code>===</code> 和 <code>!==</code>。前者只比较值的相等，后者除了值以外，还比较类型是否相同。</p>
<p>请尽量不要使用前一组，永远只使用 <code>===</code> 和 <code>!==</code>。因为==默认会进行类型转换，规则十分难记。</p>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p><code>with</code> 的本意是减少键盘输入。</p>
<p>但是，在实际运行时，解释器会首先判断变量是否存在，如果不存在的话，再判断全局变量是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用 <code>with</code> 语句。</p>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p><code>eval</code> 用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。</p>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。</p>
<h2 id="switch-贯穿"><a href="#switch-贯穿" class="headerlink" title="switch 贯穿"></a>switch 贯穿</h2><p><code>switch</code> 结构中的 <code>case</code> 语句，默认是顺序执行，除非遇到 <code>break</code>，<code>return</code> 和 <code>throw</code>。</p>
<p>贯穿容易出错，而且难以发现。建议避免 <code>switch</code> 贯穿，凡是有 <code>case</code> 的地方，一律加上 <code>break</code>。</p>
<h2 id="单行的块结构"><a href="#单行的块结构" class="headerlink" title="单行的块结构"></a>单行的块结构</h2><p><code>if</code>、<code>while</code>、<code>do</code> 和 <code>for</code>，都是块结构语句，但是也可以接受单行命令。</p>
<p>单行不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。</p>
<h2 id="和–"><a href="#和–" class="headerlink" title="++和–"></a>++和–</h2><p>递增运算符 <code>++</code> 和递减运算符 <code>--</code>，直接来自 <strong>C</strong> 语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><strong>Javascript</strong> 完全套用了 <strong>Java</strong> 的位运算符，包括按位与 <code>&amp;</code>、按位或 <code>|</code>、按位异或 <code>^</code>、按位非 <code>~</code>、左移 <code>&lt;&lt;</code>、带符号的右移 <code>&gt;&gt;</code> 和用 <strong>0</strong> 补足的右移 <code>&gt;&gt;&gt;</code>。</p>
<p>这套运算符针对的是整数，所以对 <strong>Javascript</strong> 完全无用，因为 <strong>Javascript</strong> 内部，所有数字都保存为双精度浮点数。</p>
<p><strong>Javascript</strong> 不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。</p>
<h2 id="function-语句"><a href="#function-语句" class="headerlink" title="function 语句"></a>function 语句</h2><p>在 <strong>Javascript</strong> 中定义一个函数，有两种写法：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{}</span></pre></td></tr></tbody></table></figure>

<p>和</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{};</span></pre></td></tr></tbody></table></figure>

<p>两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。</p>
<h2 id="基本数据类型的包装对象"><a href="#基本数据类型的包装对象" class="headerlink" title="基本数据类型的包装对象"></a>基本数据类型的包装对象</h2><p><strong>Javascript</strong> 的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象 <code>String</code>、<code>Number</code> 和 <code>Boolean</code>。所以，有人会这样定义相关值：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Hello World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span></pre></td></tr></tbody></table></figure>

<p>这样写完全没有必要，而且非常费解，因此建议不要使用。</p>
<p>另外，<code>new Object</code> 和 <code>new Array</code> 也不建议使用，可以用 <code>{}</code> 和 <code>[]</code> 代替。</p>
<h2 id="new-语句"><a href="#new-语句" class="headerlink" title="new 语句"></a>new 语句</h2><p>类是这样定义的：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.saying = <span class="string">"meow"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr></tbody></table></figure>

<p>然后，再生成一个对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Cat(<span class="string">"mimi"</span>);</span></pre></td></tr></tbody></table></figure>

<p>这种利用函数生成类、利用 <code>new</code> 生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上 <code>new</code>，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.beget = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>{};</span></pre></td></tr><tr><td class="code"><pre><span class="line">  F.prototype = o;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr></tbody></table></figure>

<p>创建对象时就利用这个函数，对原型对象进行操作：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: <span class="string">""</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  saying: <span class="string">"meow"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCat = <span class="built_in">Object</span>.beget(Cat);</span></pre></td></tr></tbody></table></figure>

<p>对象生成后，可以自行对相关属性进行赋值：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">myCat.name = <span class="string">"mimi"</span>;</span></pre></td></tr></tbody></table></figure>

<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>在大多数语言中，<code>void</code> 都是一种类型，表示没有值。但是在 <strong>Javascript</strong> 中，<code>void</code> 是一个运算符，接受一个运算数，并返回 <strong>undefined</strong>。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span>; <span class="comment">// undefined</span></span></pre></td></tr></tbody></table></figure>

<p>这个命令没什么用，而且很令人困惑，建议避免使用。</p>
<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/01/12_javascript_syntax_structures_you_should_not_use.html" target="_blank" rel="noopener">12种不宜使用的Javascript语法</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>用Javascript获取页面元素的位置</title>
    <url>/blog/2019/12/05/%E7%94%A8Javascript%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>制作网页的过程中，你有时候需要知道某个元素在网页上的确切位置。<br>下面的教程总结了 <strong>Javascript</strong> 在网页定位方面的相关知识。</p>
<a id="more"></a>

<h2 id="获取网页的大小"><a href="#获取网页的大小" class="headerlink" title="获取网页的大小"></a>获取网页的大小</h2><p>网页上的每个元素，都有 <code>clientHeight</code> 和 <code>clientWidth</code> 属性。这两个属性指元素的内容部分再加上 <code>padding</code> 的所占据的视觉面积，不包括 <code>border</code> 和滚动条占用的空间。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewport</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      width: <span class="built_in">document</span>.body.clientWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      height: <span class="built_in">document</span>.body.clientHeight</span></pre></td></tr><tr><td class="code"><pre><span class="line">    };</span></pre></td></tr><tr><td class="code"><pre><span class="line">  } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      width: <span class="built_in">document</span>.documentElement.clientWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      height: <span class="built_in">document</span>.documentElement.clientHeight</span></pre></td></tr><tr><td class="code"><pre><span class="line">    };</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>上面的 <code>getViewport</code> 函数就可以返回浏览器窗口的高和宽。使用的时候，有三个地方需要注意：</p>
<div class="note warning">
            <p>1）这个函数必须在页面加载完成后才能运行，否则 <strong>document</strong> 对象还没生成，浏览器会报错。</p><p>2）大多数情况下，都是 <code>document.documentElement.clientWidth</code> 返回正确值。但是，在 <strong>IE6</strong> 的<strong>quirks</strong> 模式中，<code>document.body.clientWidth</code> 返回正确的值，因此函数中加入了对文档模式的判断。</p><p>3）<strong>clientWidth</strong> 和 <strong>clientHeight</strong> 都是只读属性，不能对它们赋值。</p>
          </div>

<h2 id="获取网页大小的另一种方法"><a href="#获取网页大小的另一种方法" class="headerlink" title="获取网页大小的另一种方法"></a>获取网页大小的另一种方法</h2><p>网页上的每个元素还有 <code>scrollHeight</code> 和 <code>scrollWidth</code> 属性，指包含滚动条在内的该元素的视觉面积。<br>那么，<strong>document</strong> 对象的 <code>scrollHeight</code> 和 <code>scrollWidth</code> 属性就是网页的大小，意思就是滚动条滚过的所有长度和宽度。仿照 <strong>getViewport()</strong> 函数，可以写出 <strong>getPagearea()</strong> 函数。</p>
<p>但是，这个函数有一个问题。如果网页内容能够在浏览器窗口中全部显示，不出现滚动条，那么网页的 <code>clientWidth</code> 和 <code>scrollWidth</code> 应该相等。但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值，因此要对 <strong>getPagearea()</strong> 函数进行改写。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPagearea</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      width: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollWidth, <span class="built_in">document</span>.body.clientWidth),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      height: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollHeight, <span class="built_in">document</span>.body.clientHeight)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    };</span></pre></td></tr><tr><td class="code"><pre><span class="line">  } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      width: <span class="built_in">Math</span>.max(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.documentElement.scrollWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.documentElement.clientWidth</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      height: <span class="built_in">Math</span>.max(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.documentElement.scrollHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.documentElement.clientHeight</span></pre></td></tr><tr><td class="code"><pre><span class="line">      )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    };</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="获取网页元素的绝对位置"><a href="#获取网页元素的绝对位置" class="headerlink" title="获取网页元素的绝对位置"></a>获取网页元素的绝对位置</h2><p>网页元素的绝对位置，指该元素的左上角相对于整张网页左上角的坐标。这个绝对位置要通过计算才能得到。</p>
<p>首先，每个元素都有 <code>offsetTop</code> 和 <code>offsetLeft</code> 属性，表示该元素的左上角与父容器（<code>offsetParent</code> 对象）左上角的距离。所以，只需要将这两个值进行累加，就可以得到该元素的绝对坐标。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    actualLeft += current.offsetLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    current = current.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> actualLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span>(<span class="params">element</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> actualTop = element.offsetTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    actualTop += current.offsetTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    current = current.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> actualTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<div class="note default">
            <p>由于在表格和 <code>iframe</code> 中，<code>offsetParent</code> 对象未必等于父容器，所以上面的函数对于表格和 <code>iframe</code> 中的元素不适用。</p>
          </div>

<h2 id="获取网页元素的相对位置"><a href="#获取网页元素的相对位置" class="headerlink" title="获取网页元素的相对位置"></a>获取网页元素的相对位置</h2><p>网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标。</p>
<p>有了绝对位置以后，获得相对位置就很容易了，只要将绝对坐标减去页面的滚动条滚动的距离就可以了。滚动条滚动的垂直距离，是 <strong>document</strong> 对象的 <code>scrollTop</code> 属性；滚动条滚动的水平距离是 <strong>document</strong> 对象的 <code>scrollLeft</code> 属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementViewLeft</span>(<span class="params">element</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    actualLeft += current.offsetLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    current = current.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> elementScrollLeft = <span class="built_in">document</span>.body.scrollLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> elementScrollLeft = <span class="built_in">document</span>.documentElement.scrollLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> actualLeft - elementScrollLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementViewTop</span>(<span class="params">element</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> actualTop = element.offsetTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    actualTop += current.offsetTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    current = current.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> elementScrollTop = <span class="built_in">document</span>.body.scrollTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> elementScrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> actualTop - elementScrollTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<div class="note default">
            <p><code>scrollTop</code> 和 <code>scrollLeft</code> 属性是可以赋值的，并且会立即自动滚动网页到相应位置，因此可以利用它们改变网页元素的相对位置。另外，<code>element.scrollIntoView()</code> 方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角。</p>
          </div>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html" target="_blank" rel="noopener">用Javascript获取页面元素的位置</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Javascript闭包（Closure）</title>
    <url>/blog/2019/12/04/%E5%AD%A6%E4%B9%A0Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/</url>
    <content><![CDATA[<p>闭包（<code>closure</code>）是 <strong>Javascript</strong> 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<a id="more"></a>

<h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>闭包（<code>closure</code>）就是能够读取其他函数内部变量的函数。</p>
<p>由于在 <strong>Javascript</strong> 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><p>一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<h2 id="闭包的注意点"><a href="#闭包的注意点" class="headerlink" title="闭包的注意点"></a>闭包的注意点</h2><div class="note warning">
            <p>1). 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 <strong>IE</strong> 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>2). 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（<strong>object</strong>）使用，把闭包当作它的公用方法（<strong>Public Method</strong>），把内部变量当作它的私有属性（<strong>private value</strong>），这时一定要小心，不要随便改变父函数内部变量的值。</p>
          </div>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">学习Javascript闭包（Closure）</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>防止网页被嵌入框架的代码</title>
    <url>/blog/2019/11/28/%E9%98%B2%E6%AD%A2%E7%BD%91%E9%A1%B5%E8%A2%AB%E5%B5%8C%E5%85%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>防止使用框架（<strong>Frame</strong>），将你的网页嵌入它的网页中</p>
<a id="more"></a>

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">  <span class="comment">// 判断当前的window对象是否是top对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="built_in">window</span> != top) {</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">    <span class="comment">// 如果不是，将top对象的网址自动导向被嵌入网页的网址</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">    top.location.href = <span class="built_in">window</span>.location.href;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></tbody></table></figure>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2008/10/anti-frameset_javascript_codes.html" target="_blank" rel="noopener">防止网页被嵌入框架的代码</a></cite></footer></blockquote>

<p>问题：使用后，任何人都无法再把你的网页嵌入框架了，包括你自己在内。</p>
<p>表面上看，只要做一个判断：当前框架和顶层框架的域名是否相同，如果答案是否，就做一个 URL 重定向。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 假定 top.location.hostname 是 www.111.com，而 window.location.hostname 是 www.222.com。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (top.location.hostname != <span class="built_in">window</span>.location.hostname) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  top.location.href = <span class="built_in">window</span>.location.href;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>但是，出乎意料的是，这样写是错误的，根本无法运行。浏览器会提示代码出错！</p>
<p>因为它们跨域（<code>cross-domain</code>）了，浏览器的安全政策不允许 222.com 的网页操作 111.com 的网页，反之亦然。</p>
<p><strong>IE</strong> 把这种错误叫做“没有权限”。进一步说，浏览器甚至不允许你查看 <code>top.location.hostname</code>，跨域情况下，一看到这个对象，就直接报错。但是，<strong>Chrome</strong> 浏览器中不知为何，在跨域情况下，<strong>Chrome</strong> 对 <code>top.location.hostname</code> 不报错！</p>
<p>只能为了 <strong>Chrome</strong>，再加一段补充代码。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  top.location.hostname;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 兼容 Chrome</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (top.location.hostname != <span class="built_in">window</span>.location.hostname) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    top.location.href = <span class="built_in">window</span>.location.href;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">} <span class="keyword">catch</span> (e) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  top.location.href = <span class="built_in">window</span>.location.href;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/08/anti-frameset_javascript_codes_continued.html" target="_blank" rel="noopener">防止网页被嵌入框架的代码（续）</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2019/11/28/hello-world/</url>
    <content><![CDATA[<p>欢迎来到<a href="http://shiliuchuang.com/" target="_blank" rel="noopener">虚幻的光</a>！</p>
<a id="more"></a>

<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="建立新讯息"><a href="#建立新讯息" class="headerlink" title="建立新讯息"></a>建立新讯息</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></tbody></table></figure>

<p>更多信息：<a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">写作</a></p>
<h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></tbody></table></figure>

<p>更多信息：<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">服务器</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></tbody></table></figure>

<p>更多信息：<a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">生成</a></p>
<h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></tbody></table></figure>

<p>更多信息：<a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">部署</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
</search>

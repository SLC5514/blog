<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Javascript 面向对象编程（三）：非构造函数的继承</title>
    <url>/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%9D%9E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>这个系列的 <a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/" title="第一部分">第一部分</a> 介绍了“封装”，<a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/" title="第二部分">第二部分</a> 介绍了使用构造函数实现“继承”。</p>
<p>今天是最后一个部分，介绍不使用构造函数实现“继承”。</p>
<a id="more"></a>

<h2 id="什么是“非构造函数”的继承？"><a href="#什么是“非构造函数”的继承？" class="headerlink" title="什么是“非构造函数”的继承？"></a>什么是“非构造函数”的继承？</h2><p>比如，现在有一个对象，叫做”中国人”。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Chinese = {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  nation: <span class="string">"中国"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr></tbody></table></figure>

<p>还有一个对象，叫做”医生”。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Doctor = {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  career: <span class="string">"医生"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr></tbody></table></figure>

<p>请问怎样才能让“医生”去继承“中国人”，也就是说，我怎样才能生成一个“中国医生”的对象？</p>
<p>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现“继承”。</p>
<h2 id="object-方法"><a href="#object-方法" class="headerlink" title="object()方法"></a>object()方法</h2><p><strong>json</strong> 格式的发明人 <strong>Douglas Crockford</strong>，提出了一个 <strong>object()</strong> 函数，可以做到这一点。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>{}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  F.prototype = o;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Doctor = object(Chinese); <span class="comment">// 第一步先在父对象的基础上，生成子对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Doctor.career = <span class="string">"医生"</span>; <span class="comment">// 再加上子对象本身的属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Doctor.nation); <span class="comment">//中国</span></span></pre></td></tr></tbody></table></figure>

<p>这个 <strong>object()</strong> 函数其实只做一件事，就是把子对象的 <code>prototype</code> 属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>除了使用“prototype 链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendCopy</span>(<span class="params">p</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    c[i] = p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.uber = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Doctor = extendCopy(Chinese);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Doctor.career = <span class="string">"医生"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Doctor.nation); <span class="comment">// 中国</span></span></pre></td></tr></tbody></table></figure>

<p>这样的拷贝有一个问题。如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>所以，<strong>extendCopy()</strong> 只是拷贝基本类型的数据，我们把这种拷贝叫做“浅拷贝”。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>所谓“深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用“浅拷贝”就行了。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c = c || {};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">"object"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      c[i] = p[i].constructor === <span class="built_in">Array</span> ? [] : {};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      deepCopy(p[i], c[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      c[i] = p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    }</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Doctor = deepCopy(Chinese);</span></pre></td></tr></tbody></table></figure>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html" target="_blank" rel="noopener">Javascript 面向对象编程（三）：非构造函数的继承</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程（二）：构造函数的继承</title>
    <url>/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>这个系列的 <a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/" title="第一部分">第一部分</a>，主要介绍了如何“封装”数据和方法，以及如何从原型对象生成实例。</p>
<p>今天要介绍的是，对象之间“继承”的五种方法。</p>
<a id="more"></a>

<p>比如，现在有一个“动物”对象的构造函数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>还有一个“猫”对象的构造函数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>怎样才能使“猫”继承“动物”呢？</p>
<h2 id="构造函数绑定"><a href="#构造函数绑定" class="headerlink" title="构造函数绑定"></a>构造函数绑定</h2><p>第一种方法也是最简单的方法，使用 <code>call</code> 或 <code>apply</code> 方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr></tbody></table></figure>

<h2 id="prototype-模式"><a href="#prototype-模式" class="headerlink" title="prototype 模式"></a>prototype 模式</h2><p>第二种方法更常见，使用 <code>prototype</code> 属性。</p>
<p>如果”猫”的 <code>prototype</code> 对象，指向一个 <strong>Animal</strong> 的实例，那么所有“猫”的实例，就能继承 <strong>Animal</strong> 了。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal(); <span class="comment">// 它相当于完全删除了 prototype 对象原先的值，然后赋予一个新值。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat.prototype.constructor = Cat;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr></tbody></table></figure>

<p>任何一个 <code>prototype</code> 对象都有一个 <code>constructor</code> 属性，指向它的构造函数。<br>如果没有“<strong>Cat.prototype = new Animal();</strong>”这一行，<strong>Cat.prototype.constructor</strong> 是指向 <strong>Cat</strong> 的；<br>加了这一行以后，<strong>Cat.prototype.constructor</strong> 指向 <strong>Animal</strong>。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(Cat.prototype.constructor == Animal); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p>更重要的是，每一个实例也有一个 <code>constructor</code> 属性，默认调用 <code>prototype</code> 对象的 <code>constructor</code> 属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.constructor == Cat.prototype.constructor); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p>因此，在运行“<strong>Cat.prototype = new Animal();</strong>”这一行之后，<strong>cat1.constructor</strong> 也指向 <strong>Animal</strong>！</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.constructor == Animal); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p>这显然会导致继承链的紊乱（<strong>cat1</strong> 明明是用构造函数 <strong>Cat</strong> 生成的），因此我们必须手动纠正，将 <strong>Cat.prototype</strong> 对象的 <strong>constructor</strong> 值改为 <strong>Cat</strong>。这就是第二行的意思。</p>
<p>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了 <code>prototype</code> 对象，那么，下一步必然是为新的 <code>prototype</code> 对象加上 <code>constructor</code> 属性，并将这个属性指回原来的构造函数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">o.prototype = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">o.prototype.constructor = o;</span></pre></td></tr></tbody></table></figure>

<h2 id="直接继承-prototype"><a href="#直接继承-prototype" class="headerlink" title="直接继承 prototype"></a>直接继承 prototype</h2><p>第三种方法是对第二种方法的改进。由于 <strong>Animal</strong> 对象中，不变的属性都可以直接写入 <strong>Animal.prototype</strong>。所以，我们也可以让 <strong>Cat()</strong> 跳过 <strong>Animal()</strong>，直接继承 <code>Animal.prototype</code>。</p>
<p>现在，我们先将 Animal 对象改写：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>{}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Animal.prototype.species = <span class="string">"动物"</span>;</span></pre></td></tr></tbody></table></figure>

<p>然后，将 <strong>Cat</strong> 的 <code>prototype</code> 对象指向 <strong>Animal</strong> 的 <code>prototype</code> 对象，这样就完成了继承。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">Cat.prototype = Animal.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat.prototype.constructor = Cat; <span class="comment">// 这一句实际上把 Animal.prototype 对象的 constructor 属性也改掉了！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 缺点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Animal.prototype.constructor); <span class="comment">// Cat</span></span></pre></td></tr></tbody></table></figure>

<p>这样做的优点是效率比较高（不用执行和建立 <strong>Animal</strong> 的实例了），比较省内存。</p>
<p>缺点是 <strong>Cat.prototype</strong> 和 <strong>Animal.prototype</strong> 现在指向了同一个对象，那么任何对 <strong>Cat.prototype</strong> 的修改，都会反映到 <strong>Animal.prototype</strong>。所以，上面这一段代码其实是有问题的。请看第二行。</p>
<h2 id="利用空对象作为中介"><a href="#利用空对象作为中介" class="headerlink" title="利用空对象作为中介"></a>利用空对象作为中介</h2><p>由于“直接继承 prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  F.prototype = Parent.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Child.prototype = <span class="keyword">new</span> F();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Child.prototype.constructor = Child;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Child.uber = Parent.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 意思是为子对象设一个 uber 属性，这个属性直接指向父对象的 prototype 属性。（ uber 是一个德语词，意思是“向上”、“上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">extend(Cat, Animal);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Animal.prototype.constructor); <span class="comment">// Animal</span></span></pre></td></tr></tbody></table></figure>

<p><strong>F</strong> 是空对象，所以几乎不占内存。这时，修改 <strong>Cat</strong> 的 <code>prototype</code> 对象，就不会影响到 <strong>Animal</strong> 的 <code>prototype</code> 对象。</p>
<h2 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h2><p>上面是采用 <code>prototype</code> 对象实现继承。我们也可以换一种思路，纯粹采用“拷贝”方法实现继承。<br>简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把 Animal 的所有不变属性，都放到它的 prototype 对象上。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>{}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Animal.prototype.species = <span class="string">"动物"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 然后，再写一个函数，实现属性拷贝的目的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> p = Parent.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c = Child.prototype;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    c[i] = p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.uber = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">extend2(Cat, Animal);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.species); <span class="comment">// 动物</span></span></pre></td></tr></tbody></table></figure>

<p>这个函数的作用，就是将父对象的 <code>prototype</code> 对象中的属性，一一拷贝给 <strong>Child</strong> 对象的 <code>prototype</code> 对象。</p>
<p>未完，请继续阅读这个系列的第三部分 <a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%9D%9E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF/" title="《非构造函数的继承》">《非构造函数的继承》</a>。</p>
<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript 面向对象编程（二）：构造函数的继承</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程（一）：封装</title>
    <url>/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p><strong>Javascript</strong> 是一种基于对象（<strong>object-based</strong>）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（<strong>OOP</strong>）语言，因为它的语法中没有 <code>class</code>（类）。</p>
<p>那么，如果我们要把”属性”（<strong>property</strong>）和”方法”（<strong>method</strong>），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？</p>
<a id="more"></a>

<h2 id="生成实例对象的原始模式"><a href="#生成实例对象的原始模式" class="headerlink" title="生成实例对象的原始模式"></a>生成实例对象的原始模式</h2><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: <span class="string">""</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  color: <span class="string">""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = {}; <span class="comment">// 创建一个空对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat1.name = <span class="string">"大毛"</span>; <span class="comment">// 按照原型对象的属性赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat1.color = <span class="string">"黄色"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat2.name = <span class="string">"二毛"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat2.color = <span class="string">"黑色"</span>;</span></pre></td></tr></tbody></table></figure>

<p>这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>
<h2 id="原始模式的改进"><a href="#原始模式的改进" class="headerlink" title="原始模式的改进"></a>原始模式的改进</h2><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: name,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: color</span></pre></td></tr><tr><td class="code"><pre><span class="line">  };</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = Cat(<span class="string">"二毛"</span>, <span class="string">"黑色"</span>);</span></pre></td></tr></tbody></table></figure>

<p>这种方法的问题依然是，<strong>cat1</strong> 和 <strong>cat2</strong> 之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>为了解决从原型对象生成实例的问题，<strong>Javascript</strong> 提供了一个构造函数（<strong>Constructor</strong>）模式。</p>
<p>所谓“构造函数”，其实就是一个普通函数，但是内部使用了 <code>this</code> 变量。对构造函数使用 <code>new</code> 运算符，就能生成实例，并且 <code>this</code> 变量会绑定在实例对象上。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>, <span class="string">"黑色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.name); <span class="comment">// 大毛</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.color); <span class="comment">// 黄色</span></span></pre></td></tr></tbody></table></figure>

<p>这时 <strong>cat1</strong> 和 <strong>cat2</strong> 会自动含有一个 <code>constructor</code> 属性，指向它们的构造函数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.constructor == Cat); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat2.constructor == Cat); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p><strong>Javascript</strong> 还提供了一个 <code>instanceof</code> 运算符，验证原型对象与实例对象之间的关系。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1 <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat2 <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<h2 id="构造函数模式的问题"><a href="#构造函数模式的问题" class="headerlink" title="构造函数模式的问题"></a>构造函数模式的问题</h2><p>构造函数方法很好用，但是存在一个浪费内存的问题。</p>
<p>我们现在为 <strong>Cat</strong> 对象添加一个不变的属性 <strong>type</strong>（种类），再添加一个方法 <strong>eat</strong>（吃）。那么，原型对象 <strong>Cat</strong> 就变成了下面这样：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.type = <span class="string">"猫科动物"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">    alert(<span class="string">"吃老鼠"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  };</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>, <span class="string">"黑色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.type); <span class="comment">// 猫科动物</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat1.eat(); <span class="comment">// 吃老鼠</span></span></pre></td></tr></tbody></table></figure>

<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。<br>那就是对于每一个实例对象，<strong>type</strong> 属性和 <strong>eat()</strong> 方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.eat == cat2.eat); <span class="comment">// false</span></span></pre></td></tr></tbody></table></figure>

<h2 id="Prototype-模式"><a href="#Prototype-模式" class="headerlink" title="Prototype 模式"></a>Prototype 模式</h2><p><strong>Javascript</strong> 规定，每一个构造函数都有一个 <code>prototype</code> 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在 <code>prototype</code> 对象上。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat.prototype.type = <span class="string">"猫科动物"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  alert(<span class="string">"吃老鼠"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>, <span class="string">"黄色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>, <span class="string">"黑色"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.type); <span class="comment">// 猫科动物</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat1.eat(); <span class="comment">// 吃老鼠</span></span></pre></td></tr></tbody></table></figure>

<p>这时所有实例的 <strong>type</strong> 属性和 <strong>eat()</strong> 方法，其实都是同一个内存地址，指向 <code>prototype</code> 对象，因此就提高了运行效率。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.eat == cat2.eat); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<h2 id="Prototype-模式的验证方法"><a href="#Prototype-模式的验证方法" class="headerlink" title="Prototype 模式的验证方法"></a>Prototype 模式的验证方法</h2><p>为了配合 <code>prototype</code> 属性，<strong>Javascript</strong> 定义了一些辅助方法，帮助我们使用它。</p>
<h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h3><p>这个方法用来判断，某个 <code>proptotype</code> 对象和某个实例之间的关系。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(Cat.prototype.isPrototypeOf(cat1)); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(Cat.prototype.isPrototypeOf(cat2)); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3><p>每个实例对象都有一个 <code>hasOwnProperty()</code> 方法，用来判断某一个属性到底是本地属性，还是继承自 <code>prototype</code> 对象的属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(cat1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(cat1.hasOwnProperty(<span class="string">"type"</span>)); <span class="comment">// false</span></span></pre></td></tr></tbody></table></figure>

<h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p><code>in</code> 运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> cat1); <span class="comment">// true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">alert(<span class="string">"type"</span> <span class="keyword">in</span> cat1); <span class="comment">// true</span></span></pre></td></tr></tbody></table></figure>

<p><code>in</code> 运算符还可以用来遍历某个对象的所有属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> cat1) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  alert(<span class="string">"cat1["</span> + prop + <span class="string">"]="</span> + cat1[prop]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>未完，请继续阅读这个系列的第二部分 <a href="/blog/2019/12/05/Javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF/" title="《构造函数的继承》">《构造函数的继承》</a> 和第三部分 《非构造函数的继承》。</p>
<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html" target="_blank" rel="noopener">Javascript 面向对象编程（一）：封装</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 的 this 用法</title>
    <url>/blog/2019/12/05/Javascript%E7%9A%84this%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><code>this</code> 是 <strong>JavaScript</strong> 语言的一个关键字。</p>
<p>它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。</p>
<p>函数的不同使用场合，<code>this</code> 有不同的值。总的来说，<code>this</code> 就是函数运行时所在的环境对象。</p>
<a id="more"></a>

<h2 id="情况一：纯粹的函数调用"><a href="#情况一：纯粹的函数调用" class="headerlink" title="情况一：纯粹的函数调用"></a>情况一：纯粹的函数调用</h2><p>这是函数的最通常用法，属于全局性调用，因此 <code>this</code> 就代表全局对象。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h2><p>函数还可以作为某个对象的方法调用，这时 <code>this</code> 就指这个上级对象。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.m = test;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.m(); <span class="comment">// 1</span></span></pre></td></tr></tbody></table></figure>

<h2 id="情况三-作为构造函数调用"><a href="#情况三-作为构造函数调用" class="headerlink" title="情况三 作为构造函数调用"></a>情况三 作为构造函数调用</h2><p>所谓构造函数，就是通过这个函数，可以生成一个新对象。这时，<code>this</code> 就指这个新对象。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.x; <span class="comment">// 1</span></span></pre></td></tr></tbody></table></figure>

<h2 id="情况四-apply-调用"><a href="#情况四-apply-调用" class="headerlink" title="情况四 apply 调用"></a>情况四 apply 调用</h2><p><code>apply()</code> 是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时 <code>this</code> 指的就是这第一个参数。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = {};</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.x = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.m = test;</span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.m.apply(); <span class="comment">// 0</span></span></pre></td></tr></tbody></table></figure>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">Javascript 的 this 用法</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>12种不宜使用的Javascript语法</title>
    <url>/blog/2019/12/05/12%E7%A7%8D%E4%B8%8D%E5%AE%9C%E4%BD%BF%E7%94%A8%E7%9A%84Javascript%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>在《Javascript 语言精粹》附录 B 中，<strong>Douglas Crockford</strong> 列出了 12 种应该避免使用的 <strong>Javascript</strong> 语法，我觉得非常值得推广。</p>
<a id="more"></a>

<h2 id><a href="#" class="headerlink" title="=="></a>==</h2><p><strong>Javascript</strong> 有两组相等运算符，一组是 <code>==</code> 和 <code>!=</code>，另一组是 <code>===</code> 和 <code>!==</code>。前者只比较值的相等，后者除了值以外，还比较类型是否相同。</p>
<p>请尽量不要使用前一组，永远只使用 <code>===</code> 和 <code>!==</code>。因为==默认会进行类型转换，规则十分难记。</p>
<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p><code>with</code> 的本意是减少键盘输入。</p>
<p>但是，在实际运行时，解释器会首先判断变量是否存在，如果不存在的话，再判断全局变量是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用 <code>with</code> 语句。</p>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p><code>eval</code> 用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。</p>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。</p>
<h2 id="switch-贯穿"><a href="#switch-贯穿" class="headerlink" title="switch 贯穿"></a>switch 贯穿</h2><p><code>switch</code> 结构中的 <code>case</code> 语句，默认是顺序执行，除非遇到 <code>break</code>，<code>return</code> 和 <code>throw</code>。</p>
<p>贯穿容易出错，而且难以发现。建议避免 <code>switch</code> 贯穿，凡是有 <code>case</code> 的地方，一律加上 <code>break</code>。</p>
<h2 id="单行的块结构"><a href="#单行的块结构" class="headerlink" title="单行的块结构"></a>单行的块结构</h2><p><code>if</code>、<code>while</code>、<code>do</code> 和 <code>for</code>，都是块结构语句，但是也可以接受单行命令。</p>
<p>单行不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。</p>
<h2 id="和–"><a href="#和–" class="headerlink" title="++和–"></a>++和–</h2><p>递增运算符 <code>++</code> 和递减运算符 <code>--</code>，直接来自 <strong>C</strong> 语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><strong>Javascript</strong> 完全套用了 <strong>Java</strong> 的位运算符，包括按位与 <code>&amp;</code>、按位或 <code>|</code>、按位异或 <code>^</code>、按位非 <code>~</code>、左移 <code>&lt;&lt;</code>、带符号的右移 <code>&gt;&gt;</code> 和用 <strong>0</strong> 补足的右移 <code>&gt;&gt;&gt;</code>。</p>
<p>这套运算符针对的是整数，所以对 <strong>Javascript</strong> 完全无用，因为 <strong>Javascript</strong> 内部，所有数字都保存为双精度浮点数。</p>
<p><strong>Javascript</strong> 不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。</p>
<h2 id="function-语句"><a href="#function-语句" class="headerlink" title="function 语句"></a>function 语句</h2><p>在 <strong>Javascript</strong> 中定义一个函数，有两种写法：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{}</span></pre></td></tr></tbody></table></figure>

<p>和</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{};</span></pre></td></tr></tbody></table></figure>

<p>两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。</p>
<h2 id="基本数据类型的包装对象"><a href="#基本数据类型的包装对象" class="headerlink" title="基本数据类型的包装对象"></a>基本数据类型的包装对象</h2><p><strong>Javascript</strong> 的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象 <code>String</code>、<code>Number</code> 和 <code>Boolean</code>。所以，有人会这样定义相关值：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Hello World"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span></pre></td></tr></tbody></table></figure>

<p>这样写完全没有必要，而且非常费解，因此建议不要使用。</p>
<p>另外，<code>new Object</code> 和 <code>new Array</code> 也不建议使用，可以用 <code>{}</code> 和 <code>[]</code> 代替。</p>
<h2 id="new-语句"><a href="#new-语句" class="headerlink" title="new 语句"></a>new 语句</h2><p>类是这样定义的：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.saying = <span class="string">"meow"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr></tbody></table></figure>

<p>然后，再生成一个对象</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Cat(<span class="string">"mimi"</span>);</span></pre></td></tr></tbody></table></figure>

<p>这种利用函数生成类、利用 <code>new</code> 生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上 <code>new</code>，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.beget = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>{};</span></pre></td></tr><tr><td class="code"><pre><span class="line">  F.prototype = o;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr></tbody></table></figure>

<p>创建对象时就利用这个函数，对原型对象进行操作：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: <span class="string">""</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  saying: <span class="string">"meow"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">};</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCat = <span class="built_in">Object</span>.beget(Cat);</span></pre></td></tr></tbody></table></figure>

<p>对象生成后，可以自行对相关属性进行赋值：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line">myCat.name = <span class="string">"mimi"</span>;</span></pre></td></tr></tbody></table></figure>

<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>在大多数语言中，<code>void</code> 都是一种类型，表示没有值。但是在 <strong>Javascript</strong> 中，<code>void</code> 是一个运算符，接受一个运算数，并返回 <strong>undefined</strong>。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span>; <span class="comment">// undefined</span></span></pre></td></tr></tbody></table></figure>

<p>这个命令没什么用，而且很令人困惑，建议避免使用。</p>
<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/01/12_javascript_syntax_structures_you_should_not_use.html" target="_blank" rel="noopener">12种不宜使用的Javascript语法</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>用Javascript获取页面元素的位置</title>
    <url>/blog/2019/12/05/%E7%94%A8Javascript%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>制作网页的过程中，你有时候需要知道某个元素在网页上的确切位置。<br>下面的教程总结了 <strong>Javascript</strong> 在网页定位方面的相关知识。</p>
<a id="more"></a>

<h2 id="获取网页的大小"><a href="#获取网页的大小" class="headerlink" title="获取网页的大小"></a>获取网页的大小</h2><p>网页上的每个元素，都有 <code>clientHeight</code> 和 <code>clientWidth</code> 属性。这两个属性指元素的内容部分再加上 <code>padding</code> 的所占据的视觉面积，不包括 <code>border</code> 和滚动条占用的空间。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewport</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      width: <span class="built_in">document</span>.body.clientWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      height: <span class="built_in">document</span>.body.clientHeight</span></pre></td></tr><tr><td class="code"><pre><span class="line">    };</span></pre></td></tr><tr><td class="code"><pre><span class="line">  } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      width: <span class="built_in">document</span>.documentElement.clientWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      height: <span class="built_in">document</span>.documentElement.clientHeight</span></pre></td></tr><tr><td class="code"><pre><span class="line">    };</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>上面的 <code>getViewport</code> 函数就可以返回浏览器窗口的高和宽。使用的时候，有三个地方需要注意：</p>
<div class="note warning">
            <p>1）这个函数必须在页面加载完成后才能运行，否则 <strong>document</strong> 对象还没生成，浏览器会报错。</p><p>2）大多数情况下，都是 <code>document.documentElement.clientWidth</code> 返回正确值。但是，在 <strong>IE6</strong> 的<strong>quirks</strong> 模式中，<code>document.body.clientWidth</code> 返回正确的值，因此函数中加入了对文档模式的判断。</p><p>3）<strong>clientWidth</strong> 和 <strong>clientHeight</strong> 都是只读属性，不能对它们赋值。</p>
          </div>

<h2 id="获取网页大小的另一种方法"><a href="#获取网页大小的另一种方法" class="headerlink" title="获取网页大小的另一种方法"></a>获取网页大小的另一种方法</h2><p>网页上的每个元素还有 <code>scrollHeight</code> 和 <code>scrollWidth</code> 属性，指包含滚动条在内的该元素的视觉面积。<br>那么，<strong>document</strong> 对象的 <code>scrollHeight</code> 和 <code>scrollWidth</code> 属性就是网页的大小，意思就是滚动条滚过的所有长度和宽度。仿照 <strong>getViewport()</strong> 函数，可以写出 <strong>getPagearea()</strong> 函数。</p>
<p>但是，这个函数有一个问题。如果网页内容能够在浏览器窗口中全部显示，不出现滚动条，那么网页的 <code>clientWidth</code> 和 <code>scrollWidth</code> 应该相等。但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值，因此要对 <strong>getPagearea()</strong> 函数进行改写。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPagearea</span>(<span class="params"></span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      width: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollWidth, <span class="built_in">document</span>.body.clientWidth),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      height: <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollHeight, <span class="built_in">document</span>.body.clientHeight)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    };</span></pre></td></tr><tr><td class="code"><pre><span class="line">  } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">      width: <span class="built_in">Math</span>.max(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.documentElement.scrollWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.documentElement.clientWidth</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      height: <span class="built_in">Math</span>.max(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.documentElement.scrollHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">document</span>.documentElement.clientHeight</span></pre></td></tr><tr><td class="code"><pre><span class="line">      )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    };</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<h2 id="获取网页元素的绝对位置"><a href="#获取网页元素的绝对位置" class="headerlink" title="获取网页元素的绝对位置"></a>获取网页元素的绝对位置</h2><p>网页元素的绝对位置，指该元素的左上角相对于整张网页左上角的坐标。这个绝对位置要通过计算才能得到。</p>
<p>首先，每个元素都有 <code>offsetTop</code> 和 <code>offsetLeft</code> 属性，表示该元素的左上角与父容器（<code>offsetParent</code> 对象）左上角的距离。所以，只需要将这两个值进行累加，就可以得到该元素的绝对坐标。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    actualLeft += current.offsetLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    current = current.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> actualLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span>(<span class="params">element</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> actualTop = element.offsetTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    actualTop += current.offsetTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    current = current.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> actualTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<div class="note default">
            <p>由于在表格和 <code>iframe</code> 中，<code>offsetParent</code> 对象未必等于父容器，所以上面的函数对于表格和 <code>iframe</code> 中的元素不适用。</p>
          </div>

<h2 id="获取网页元素的相对位置"><a href="#获取网页元素的相对位置" class="headerlink" title="获取网页元素的相对位置"></a>获取网页元素的相对位置</h2><p>网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标。</p>
<p>有了绝对位置以后，获得相对位置就很容易了，只要将绝对坐标减去页面的滚动条滚动的距离就可以了。滚动条滚动的垂直距离，是 <strong>document</strong> 对象的 <code>scrollTop</code> 属性；滚动条滚动的水平距离是 <strong>document</strong> 对象的 <code>scrollLeft</code> 属性。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementViewLeft</span>(<span class="params">element</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> actualLeft = element.offsetLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    actualLeft += current.offsetLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    current = current.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> elementScrollLeft = <span class="built_in">document</span>.body.scrollLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> elementScrollLeft = <span class="built_in">document</span>.documentElement.scrollLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> actualLeft - elementScrollLeft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementViewTop</span>(<span class="params">element</span>) </span>{</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> actualTop = element.offsetTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> current = element.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    actualTop += current.offsetTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    current = current.offsetParent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> elementScrollTop = <span class="built_in">document</span>.body.scrollTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  } <span class="keyword">else</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> elementScrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> actualTop - elementScrollTop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<div class="note default">
            <p><code>scrollTop</code> 和 <code>scrollLeft</code> 属性是可以赋值的，并且会立即自动滚动网页到相应位置，因此可以利用它们改变网页元素的相对位置。另外，<code>element.scrollIntoView()</code> 方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角。</p>
          </div>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html" target="_blank" rel="noopener">用Javascript获取页面元素的位置</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Javascript闭包（Closure）</title>
    <url>/blog/2019/12/04/%E5%AD%A6%E4%B9%A0Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/</url>
    <content><![CDATA[<p>闭包（<code>closure</code>）是 <strong>Javascript</strong> 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<a id="more"></a>

<h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>闭包（<code>closure</code>）就是能够读取其他函数内部变量的函数。</p>
<p>由于在 <strong>Javascript</strong> 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><p>一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<h2 id="闭包的注意点"><a href="#闭包的注意点" class="headerlink" title="闭包的注意点"></a>闭包的注意点</h2><div class="note warning">
            <p>1). 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 <strong>IE</strong> 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>2). 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（<strong>object</strong>）使用，把闭包当作它的公用方法（<strong>Public Method</strong>），把内部变量当作它的私有属性（<strong>private value</strong>），这时一定要小心，不要随便改变父函数内部变量的值。</p>
          </div>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="noopener">学习Javascript闭包（Closure）</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>防止网页被嵌入框架的代码</title>
    <url>/blog/2019/11/28/%E9%98%B2%E6%AD%A2%E7%BD%91%E9%A1%B5%E8%A2%AB%E5%B5%8C%E5%85%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>防止使用框架（<strong>Frame</strong>），将你的网页嵌入它的网页中</p>
<a id="more"></a>

<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">  <span class="comment">// 判断当前的window对象是否是top对象</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="built_in">window</span> != top) {</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="actionscript">    <span class="comment">// 如果不是，将top对象的网址自动导向被嵌入网页的网址</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="javascript">    top.location.href = <span class="built_in">window</span>.location.href;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></tbody></table></figure>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2008/10/anti-frameset_javascript_codes.html" target="_blank" rel="noopener">防止网页被嵌入框架的代码</a></cite></footer></blockquote>

<p>问题：使用后，任何人都无法再把你的网页嵌入框架了，包括你自己在内。</p>
<p>表面上看，只要做一个判断：当前框架和顶层框架的域名是否相同，如果答案是否，就做一个 URL 重定向。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 假定 top.location.hostname 是 www.111.com，而 window.location.hostname 是 www.222.com。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (top.location.hostname != <span class="built_in">window</span>.location.hostname) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  top.location.href = <span class="built_in">window</span>.location.href;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<p>但是，出乎意料的是，这样写是错误的，根本无法运行。浏览器会提示代码出错！</p>
<p>因为它们跨域（<code>cross-domain</code>）了，浏览器的安全政策不允许 222.com 的网页操作 111.com 的网页，反之亦然。</p>
<p><strong>IE</strong> 把这种错误叫做“没有权限”。进一步说，浏览器甚至不允许你查看 <code>top.location.hostname</code>，跨域情况下，一看到这个对象，就直接报错。但是，<strong>Chrome</strong> 浏览器中不知为何，在跨域情况下，<strong>Chrome</strong> 对 <code>top.location.hostname</code> 不报错！</p>
<p>只能为了 <strong>Chrome</strong>，再加一段补充代码。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  top.location.hostname;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 兼容 Chrome</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (top.location.hostname != <span class="built_in">window</span>.location.hostname) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">    top.location.href = <span class="built_in">window</span>.location.href;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  }</span></pre></td></tr><tr><td class="code"><pre><span class="line">} <span class="keyword">catch</span> (e) {</span></pre></td></tr><tr><td class="code"><pre><span class="line">  top.location.href = <span class="built_in">window</span>.location.href;</span></pre></td></tr><tr><td class="code"><pre><span class="line">}</span></pre></td></tr></tbody></table></figure>

<blockquote><footer><strong>阮一峰</strong><cite><a href="http://www.ruanyifeng.com/blog/2010/08/anti-frameset_javascript_codes_continued.html" target="_blank" rel="noopener">防止网页被嵌入框架的代码（续）</a></cite></footer></blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/2019/11/28/hello-world/</url>
    <content><![CDATA[<p>欢迎来到<a href="http://shiliuchuang.com/" target="_blank" rel="noopener">虚幻的光</a>！</p>
<a id="more"></a>

<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="建立新讯息"><a href="#建立新讯息" class="headerlink" title="建立新讯息"></a>建立新讯息</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></tbody></table></figure>

<p>更多信息：<a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">写作</a></p>
<h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></tbody></table></figure>

<p>更多信息：<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">服务器</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></tbody></table></figure>

<p>更多信息：<a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">生成</a></p>
<h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></tbody></table></figure>

<p>更多信息：<a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">部署</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
</search>
